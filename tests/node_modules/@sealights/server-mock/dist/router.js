"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MockRouter = void 0;
var body_parser_1 = __importDefault(require("body-parser"));
var clone_1 = __importDefault(require("clone"));
var express_1 = __importDefault(require("express"));
var fs_1 = __importDefault(require("fs"));
var http_status_codes_1 = __importDefault(require("http-status-codes"));
var render_1 = require("./render");
var routes_1 = require("./routes");
var state_1 = require("./state");
var utils_1 = require("./utils");
var port = parseInt(process.env.SERVER_PORT || '9900');
var router = express_1.default.Router();
var state = clone_1.default(state_1.CLEAN_STATE);
var recommendedVersionsPaths = {};
var recommendedVersions = {};
/**
 * Configure the router
 */
var configure = function () {
    router.use(function (req, res, next) {
        var routeSettings = routes_1.MockRoutes.getRouteSettings(req.method, req);
        if (routeSettings) {
            if (routeSettings.requestsBeforeStatusExpires && routeSettings.requestIndex >= routeSettings.requestsBeforeStatusExpires) {
                console.log(req.url, '- not forcing behavior');
                next();
            }
            else {
                routeSettings.requestIndex++;
                console.log(req.url, '- forcing behavior');
                res.status(routeSettings.status);
                res.end();
            }
        }
        else {
            console.log(req.url, '- not forcing behavior');
            next();
        }
    });
    /**
     * Get Web Token
     */
    router.get('/api/test/token', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(utils_1.Utils.getWebToken());
        res.end();
    });
    /**
     * Web App
     */
    router.get('/', function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
        var html;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, render_1.Renderer.render()];
                case 1:
                    html = _a.sent();
                    res.send(html);
                    res.end();
                    return [2 /*return*/];
            }
        });
    }); });
    /**
     * Get all route settings
     */
    router.get('/settings', function (req, res) {
        res.send(routes_1.MockRoutes.ROUTES);
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    /**
     * Change route[s] settings
     */
    router.put('/settings', function (req, res) {
        var _a;
        var changes = (_a = req.body) !== null && _a !== void 0 ? _a : [];
        changes.forEach(function (change) {
            var route = routes_1.MockRoutes.getRoute(change.method, change.url);
            if (route) {
                routes_1.MockRoutes.configureRoute(route, change.settings);
            }
            else {
                console.log("Route " + change.method + " " + change.url + " not found");
            }
        });
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    /**
     * Reset all route settings
     */
    router.put('/settings/reset', function (req, res) {
        routes_1.MockRoutes.resetRoutes();
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    /**
     * Reset  the mock state
     */
    router.get('/api/test/reset', function (req, res) {
        console.log("State reset: For test '" + req.query.testName + "'");
        state = clone_1.default(state_1.CLEAN_STATE);
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    /**
     * Endpoints for agent tests
     */
    /**
     * =======================================================================
     * Build mapping (scan) API
     * =======================================================================
     */
    router.post('/api/v4/agents/buildmapping', function (req, res) {
        console.log("POST build mapping: BuildSession='" + req.body.meta.buildSessionId + "'");
        state.buildMaps.push(req.body);
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    router.post('/api/v3/agents/buildmapping', function (req, res) {
        console.log("POST build mapping: BuildSession='" + req.body.meta.buildSessionId + "'");
        state.buildMaps.push(req.body);
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    router.get('/api/test/buildmapping', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.buildMaps);
        res.end();
    });
    router.get('/api/test/buildmappingcount', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.buildMaps.length.toString());
        res.end();
    });
    /**
     * =======================================================================
     * Blob store API
     * =======================================================================
     */
    var rawParser = body_parser_1.default.raw({ type: '*/*' });
    router.post('/api/v1/agents/blobs/:buildSessionId/:blobId', rawParser, function (req, res) {
        var buildSessionId = req.params.buildSessionId;
        var blobId = req.params.blobId;
        var blobType = req.query.blobType;
        console.log("POST Blob: BuildSessionId='" + buildSessionId + "' Type='" + blobType + "' BlobId='" + blobId + "' Len=" + req.body.length);
        state.blobs[buildSessionId] = state.blobs[buildSessionId] || {};
        if (!state.blobs[buildSessionId][blobId]) {
            state.blobs[buildSessionId][blobId] = { type: blobType, data: Array.from(req.body) };
            res.status(http_status_codes_1.default.OK);
            console.log('OK');
        }
        else {
            res.status(http_status_codes_1.default.CONFLICT);
            console.log('Conflict, already exists');
        }
        res.end();
    });
    router.get('/api/v1/agents/blobs/:buildSessionId/:blobId', function (req, res) {
        var buildSessionId = req.params.buildSessionId;
        var blobId = req.params.blobId;
        console.log("GET Blob (by ID): BuildSessionId='" + buildSessionId + "' BlobId='" + blobId + "'");
        if (!state.blobs[buildSessionId][blobId]) {
            res.status(http_status_codes_1.default.NOT_FOUND);
            console.log('No data for requested blob ID');
        }
        else {
            var data = state.blobs[buildSessionId][blobId].data;
            res.send(data);
            res.status(http_status_codes_1.default.OK);
            console.log("Sent " + data.length + " bytes back");
        }
        res.end();
    });
    router.get('/api/v1/agents/blobs/:buildSessionId', function (req, res) {
        var buildSessionId = req.params.buildSessionId;
        var blobType = req.query.blobType;
        var view = req.query.view;
        if (view == 'concatBinary') {
            sendConcatenatedBlobs(res, buildSessionId, blobType);
        }
        else if (view == 'concatJson') {
            sendJsonArrBlobs(res, buildSessionId, blobType);
        }
        else {
            sendBlobList(res, buildSessionId, blobType);
        }
        res.end();
    });
    function getBlobsOfType(buildSessionId, blobType) {
        var _a;
        var blobs = (_a = state.blobs[buildSessionId]) !== null && _a !== void 0 ? _a : {};
        var list = [];
        for (var _i = 0, _b = Object.keys(blobs).sort(); _i < _b.length; _i++) {
            var k = _b[_i];
            if ((blobType == undefined) || blobs[k].type == blobType) {
                list.push(k);
            }
        }
        return list;
    }
    function sendConcatenatedBlobs(res, buildSessionId, blobType) {
        console.log("GET Blob (concatenated): BuildSessionId='" + buildSessionId + "' Type='" + blobType + "'");
        var dataList = getBlobsOfType(buildSessionId, blobType).map(function (k) { return Buffer.from(state.blobs[buildSessionId][k].data); });
        if (dataList.length) {
            var data = Buffer.concat(dataList);
            res.status(http_status_codes_1.default.OK);
            res.send(data);
            console.log("Sent " + data.length + " bytes in " + dataList.length + " parts");
        }
        else {
            res.status(http_status_codes_1.default.NOT_FOUND);
            console.log('No data found');
        }
    }
    function sendJsonArrBlobs(res, buildSessionId, blobType) {
        console.log("GET Blob (concatenated): BuildSessionId='" + buildSessionId + "' Type='" + blobType + "'");
        var blobsBuffers = getBlobsOfType(buildSessionId, blobType).map(function (k) { return Buffer.from(state.blobs[buildSessionId][k].data); });
        var jsonArr = blobsBuffers.map(function (buffer) { return JSON.parse(buffer.toString()); });
        res.status(http_status_codes_1.default.OK);
        res.send(jsonArr);
    }
    function sendBlobList(res, buildSessionId, blobType) {
        console.log("GET Blob (list): BuildSessionId='" + buildSessionId + "' Type='" + blobType + "'");
        var blobList = getBlobsOfType(buildSessionId, blobType);
        var r = [];
        for (var _i = 0, blobList_1 = blobList; _i < blobList_1.length; _i++) {
            var k = blobList_1[_i];
            r.push({ blobId: k, type: state.blobs[buildSessionId][k].type });
        }
        res.status(http_status_codes_1.default.OK);
        res.send(r);
        console.log("Sent list of " + r.length + " blobs");
    }
    router.get('/api/test/blobs', function (req, res) {
        console.log('Test Blob: Sending all stored data...');
        res.status(http_status_codes_1.default.OK);
        res.send(state.blobs);
        res.end();
    });
    /**
     * =======================================================================
     * Test events API
     * =======================================================================
     */
    router.post('/api/v2/agents/events', function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!state.mockConfig.responseDelay_ms.eventsRequest) return [3 /*break*/, 2];
                    return [4 /*yield*/, utils_1.Utils.sleep(state.mockConfig.responseDelay_ms.eventsRequest)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    state.testEvents.push(req.body);
                    res.status(http_status_codes_1.default.OK);
                    res.end();
                    return [2 /*return*/];
            }
        });
    }); });
    router.get('/api/test/agents/events', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.testEvents);
        res.end();
    });
    /**
     * =======================================================================
     * Agent events API
     * =======================================================================
     */
    router.post('/api/v3/agents/agent-events', function (req, res) {
        console.log('Adding agent event:', req.body);
        state.agentEvents.push(req.body);
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    router.get('/api/test/v3/agents/agent-events', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.agentEvents);
        res.end();
    });
    /**
     * =======================================================================
     * Build end API
     * =======================================================================
     */
    router.post('/api/v3/agents/buildend', function (req, res) {
        console.log('recived build end request');
        state.buildStatus = req.body;
        ++state.buildEndCount;
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    router.get('/api/test/buildend', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.buildStatus);
        res.end();
    });
    router.get('/api/test/buildendCount', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.buildEndCount.toString());
        res.end();
    });
    /**
     * =======================================================================
     * Config API
     * =======================================================================
     */
    router.get('/api/v2/config', function (req, res) {
        console.log('received config request');
        state.buildStatus = req.body;
        res.status(http_status_codes_1.default.OK);
        res.json({ enabled: state.mockConfig.enabled });
        res.end();
    });
    router.post('/api/test/setEnabled', function (req, res) {
        state.mockConfig.enabled = req.body.enabled === 'true';
        res.status(http_status_codes_1.default.OK).end();
    });
    /**
     * =======================================================================
     * Log submission API
     * =======================================================================
     */
    router.post('/api/v2/logsubmission', function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!state.mockConfig.responseDelay_ms.logsRequest) return [3 /*break*/, 2];
                    return [4 /*yield*/, utils_1.Utils.sleep(state.mockConfig.responseDelay_ms.logsRequest)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    console.log('POST Log received from agent');
                    state.allReceivedLogs.push(req.body);
                    res.status(http_status_codes_1.default.CREATED);
                    res.end();
                    return [2 /*return*/];
            }
        });
    }); });
    router.get('/api/test/logs', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.allReceivedLogs);
        res.end();
    });
    /**
     * =======================================================================
     * Build session API
     * =======================================================================
     */
    router.post('/api/v2/agents/buildsession', function (req, res) {
        var customerId = req.body.customerId;
        var appName = req.body.appName;
        var branchName = req.body.branchName;
        var buildName = req.body.buildName;
        console.log("POST New build session: app='" + appName + "' branch='" + branchName + "' build='" + buildName + "' customerId='" + customerId + "'");
        if (customerId !== null && customerId !== 'SeaLights') {
            console.log('REJECT: CustomerId should be SeaLights');
            res.status(http_status_codes_1.default.INTERNAL_SERVER_ERROR);
            res.end();
            return;
        }
        var sessionName = appName + "/" + branchName + "/" + buildName;
        if (!state.buildSessions[sessionName]) {
            var bs = utils_1.Utils.createNewBuildSession(customerId, appName, branchName, buildName, req.body.additionalParams);
            state.buildSessions[sessionName] = bs;
            console.log("Created new build session: id='" + bs.buildSessionId + "'");
            res.status(http_status_codes_1.default.CREATED);
            res.send("\"" + bs.buildSessionId + "\"");
        }
        else {
            console.log('Conflict, build session already exists');
            res.status(http_status_codes_1.default.CONFLICT);
        }
        res.end();
    });
    router.get('/api/v2/agents/buildsession/:buildSessionId', function (req, res) {
        console.log("GET Build session: id='" + req.params.buildSessionId + "'");
        var bsKey = Object.keys(state.buildSessions).find(function (k) {
            return state.buildSessions[k].buildSessionId == req.params.buildSessionId;
        });
        if (bsKey) {
            console.log('Sending data back');
            res.status(http_status_codes_1.default.OK);
            res.send(state.buildSessions[bsKey]);
        }
        else {
            console.log('Not found');
            res.status(http_status_codes_1.default.NOT_FOUND);
        }
        res.end();
    });
    router.get('/api/test/buildsessions', function (req, res) {
        console.log('Test Build Sessions: Sending all stored data...');
        res.status(http_status_codes_1.default.OK);
        res.send(state.buildSessions);
        res.end();
    });
    /**
     * =======================================================================
     * Footprints API
     * =======================================================================
     */
    router.post('/api/v5/agents/footprints', function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!state.mockConfig.responseDelay_ms.footprintsRequest) return [3 /*break*/, 2];
                    return [4 /*yield*/, utils_1.Utils.sleep(state.mockConfig.responseDelay_ms.footprintsRequest)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    console.log("POST Footprints");
                    state.allReceivedFootprints.push(req.body);
                    res.status(http_status_codes_1.default.OK);
                    res.end();
                    return [2 /*return*/];
            }
        });
    }); });
    router.post('/api/v6/agents/:executionBsId/footprints/:testStage/:buildSessionId', function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!state.mockConfig.responseDelay_ms.footprintsRequest) return [3 /*break*/, 2];
                    return [4 /*yield*/, utils_1.Utils.sleep(state.mockConfig.responseDelay_ms.footprintsRequest)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    console.log("POST Footprints");
                    state.allReceivedFootprints.push(req.body);
                    res.status(http_status_codes_1.default.OK);
                    res.end();
                    return [2 /*return*/];
            }
        });
    }); });
    router.get('/api/test/footprints', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.allReceivedFootprints);
        res.end();
    });
    /**
     * =======================================================================
     * Production data
     * =======================================================================
     */
    router.post('/api/v1/agents/productiondata/bsid/:buildSessionId', function (req, res) {
        var buildSessionId = req.params.buildSessionId;
        console.log("POST production data: bsid=" + buildSessionId);
        if (!state.allReceivedProdData[buildSessionId]) {
            state.allReceivedProdData[buildSessionId] = [];
        }
        state.allReceivedProdData[buildSessionId].push(req.body);
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    router.get('/api/test/productiondata', function (req, res) {
        res.status(http_status_codes_1.default.OK);
        res.send(state.allReceivedProdData);
        res.end();
    });
    router.get('/api/test/productiondata/:buildSessionId', function (req, res) {
        var buildSessionId = req.params.buildSessionId;
        console.log('Test: sending production data bsid=${buildSessionId}');
        if (state.allReceivedProdData[buildSessionId]) {
            var data = state.allReceivedProdData[buildSessionId];
            console.log("submit count = " + data.length);
            res.status(http_status_codes_1.default.OK);
            res.send(data);
        }
        else {
            res.status(http_status_codes_1.default.NOT_FOUND);
            console.log("No production data found for buildSessionId " + buildSessionId);
        }
        res.end();
    });
    /**
     * =======================================================================
     * Active execution API
     * =======================================================================
     */
    router.get('/api/v3/testExecution', function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
        var body;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!state.mockConfig.responseDelay_ms.testExecutionRequest) return [3 /*break*/, 2];
                    return [4 /*yield*/, utils_1.Utils.sleep(state.mockConfig.responseDelay_ms.testExecutionRequest)];
                case 1:
                    _a.sent();
                    _a.label = 2;
                case 2:
                    body = { status: 'created' };
                    utils_1.Utils.sendResponse(res, http_status_codes_1.default.OK, 'application/json', body);
                    return [2 /*return*/];
            }
        });
    }); });
    router.delete('/api/v3/testExecution', function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            state.execution = { execution: null };
            res.status(http_status_codes_1.default.OK).end();
            return [2 /*return*/];
        });
    }); });
    router.get('/api/v4/testExecution/:labId', function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
        var body;
        return __generator(this, function (_a) {
            if (state.execution) {
                body = state.execution;
            }
            else {
                // The default execution value is 'created' in order to agent will always send footprints
                body = { execution: { executionId: 'defaultExecutionId', buildSessionId: 'defaultBsId', testStage: 'Unit Tests', status: 'created' } };
            }
            utils_1.Utils.sendResponse(res, http_status_codes_1.default.OK, 'application/json', body);
            return [2 /*return*/];
        });
    }); });
    router.get('/api/v4/testExecution/:labId?executionId=defaultExecutionId', function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
        var body;
        return __generator(this, function (_a) {
            if (state.execution) {
                body = state.execution;
            }
            else {
                // The default execution value is 'created' in order to agent will always send footprints
                body = { execution: { executionId: 'defaultExecutionId', buildSessionId: 'defaultBsId', testStage: 'Unit Tests', status: 'created' } };
            }
            utils_1.Utils.sendResponse(res, http_status_codes_1.default.OK, 'application/json', body);
            return [2 /*return*/];
        });
    }); });
    router.post('/api/test/setDelay', function (req, res) {
        var requestToBeDelayed = req.body.requestToBeDelayed;
        var delay = req.body.duration_ms;
        state.mockConfig.responseDelay_ms[requestToBeDelayed] = delay;
        res.status(http_status_codes_1.default.OK).end();
    });
    router.post('/api/test/testExecution', function (req, res, next) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            state.execution = req.body.execution;
            res.status(http_status_codes_1.default.OK).end();
            return [2 /*return*/];
        });
    }); });
    /**
     * =======================================================================
     * Recommended version API
     * =======================================================================
     */
    router.get('/api/v1/agents/:agentType/recommended', function (req, res) {
        var agentType = req.params.agentType;
        var redirect = req.query.redirect;
        var customerId = req.query.customerId;
        var agentTypePathObject = recommendedVersionsPaths[agentType] || {};
        var path = agentTypePathObject[customerId] || agentTypePathObject['default'];
        if (!path) {
            var errMessage = "Path for agent type '" + agentType + "' not found";
            console.error(errMessage);
            res.status(http_status_codes_1.default.NOT_FOUND);
            res.send(errMessage);
        }
        if (parseInt(redirect) === 1) {
            res.header('Location', "/api/test/redirect/recommended/?path=" + path);
            res.header('cache-control', 'no-store');
            res.header('x-sl-agent-version', agentType);
            res.header('x-sl-agent-date', new Date().valueOf().toString());
            res.status(http_status_codes_1.default.MOVED_TEMPORARILY);
            return res.end();
        }
        res.status(http_status_codes_1.default.NOT_FOUND);
        res.send('Not implemented yet');
    });
    router.get('/api/v2/agents/:agentType/recommended', function (req, res) {
        var DEFAULT_VERSION = 'fake version';
        function createResponseBody(agentType, version) {
            return {
                type: agentType,
                generated: Date.now(),
                meta: {
                    url: "localhost:" + port + "/api/v2/agents/" + agentType + "/recommended",
                    query: {
                        agentType: "" + agentType
                    }
                },
                agent: {
                    name: agentType,
                    version: version,
                    date: '2020-04-01T12:00:00.000Z',
                    url: 'fake url'
                }
            };
        }
        var agentType = req.params.agentType;
        var recommendedVersion = recommendedVersions[agentType];
        if (recommendedVersion) {
            res.status(http_status_codes_1.default.OK);
            res.send(createResponseBody(agentType, recommendedVersion.version));
            return;
        }
        console.warn("No recommended version available for " + agentType + ", using default: '" + DEFAULT_VERSION + "'");
        res.status(http_status_codes_1.default.OK);
        res.send(createResponseBody(agentType, DEFAULT_VERSION));
    });
    router.post('/api/test/recommended', function (req, res) {
        var agentType = req.body.agentType;
        var customerId = req.body.customerId;
        var filePath = req.body.filePath;
        if (!agentType) {
            res.status(http_status_codes_1.default.BAD_REQUEST);
            res.send('Agent type not provided');
        }
        if (!filePath) {
            res.status(http_status_codes_1.default.BAD_REQUEST);
            res.send('Filepath not provided');
        }
        var customerIdKey = customerId !== null && customerId !== void 0 ? customerId : 'default';
        recommendedVersionsPaths[agentType] = {};
        recommendedVersionsPaths[agentType][customerIdKey] = filePath;
        console.log("Recommended agent path for agent '" + agentType + "' set to '" + filePath + "'");
        res.end();
    });
    router.get('/api/test/redirect/recommended/', function (req, res) {
        var filePath = req.query.path;
        if (fs_1.default.existsSync(filePath)) {
            res.sendFile(filePath, function (err) {
                if (err) {
                    console.log("Error while sending file '" + filePath + "'");
                }
                else {
                    console.log('Sent:', filePath);
                }
            });
        }
        else {
            var errMessage = "File '" + filePath + " does not exists";
            console.error(errMessage);
            res.status(http_status_codes_1.default.BAD_REQUEST);
            res.send(errMessage);
        }
    });
    router.post('/api/test/agents/:agentType/recommended', function (req, res) {
        var agentType = req.params.agentType;
        var version = req.body.version;
        if (!version) {
            res.status(http_status_codes_1.default.BAD_REQUEST);
            res.send('Version not provided');
            return;
        }
        recommendedVersions[agentType] = { 'version': version };
        console.log("Recommended version for '" + agentType + "' is now '" + version + "'");
        res.status(http_status_codes_1.default.CREATED);
        res.send("Created the version '" + version + "' for '" + agentType + "'");
    });
    /**
     * =======================================================================
     * Active build session id API
     * =======================================================================
     */
    router.get('/api/v1/lab-ids/:labId/build-sessions/active', function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (state.activeBuildSession) {
                utils_1.Utils.sendResponse(res, http_status_codes_1.default.OK, 'application/json', state.activeBuildSession);
            }
            else {
                res.status(http_status_codes_1.default.NOT_FOUND);
                res.send();
            }
            return [2 /*return*/];
        });
    }); });
    router.post('/api/test/lab-ids/build-sessions/active/:buildSessionId', function (req, res) {
        var keys = Object.keys(state.buildSessions);
        keys.forEach(function (key) {
            if (state.buildSessions[key].buildSessionId == req.params.buildSessionId) {
                state.activeBuildSession = state.buildSessions[key];
            }
        });
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
    /**
     * =======================================================================
     * Test recommendation API
     * =======================================================================
     */
    router.get('/api/v2/test-exclusions/:buildSessionId/:testStage', function (req, res) { return __awaiter(void 0, void 0, void 0, function () {
        var buildSessionId, testStage, resBody, status;
        return __generator(this, function (_a) {
            buildSessionId = req.params.buildSessionId;
            testStage = req.params.testStage;
            state.testRecommendations[buildSessionId] = state.testRecommendations[buildSessionId] || {};
            resBody = state.testRecommendations[buildSessionId][testStage];
            status = resBody ? http_status_codes_1.default.OK : http_status_codes_1.default.NOT_FOUND;
            utils_1.Utils.sendResponse(res, status, 'application/json', resBody);
            return [2 /*return*/];
        });
    }); });
    router.post('/api/test/test-exclusions/:buildSessionId/:testStage', function (req, res) {
        var buildSessionId = req.params.buildSessionId;
        var testStage = req.params.testStage;
        state.testRecommendations[buildSessionId] = state.testRecommendations[buildSessionId] || {};
        state.testRecommendations[buildSessionId][testStage] = req.body;
        res.status(http_status_codes_1.default.OK);
        res.end();
    });
};
var MockRouter = { router: router, configure: configure };
exports.MockRouter = MockRouter;
